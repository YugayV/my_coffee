# Kafe Booking – Полный гайд по проекту (KR / RU / EN кафе-платформа)

Этот документ описывает проект **мультиплатформенного приложения** для бронирования столиков в кафе по всей Корее, с упором на:

- веб-интерфейс (главная страница);
- регистрацию пользователей и владельцев кафе;
- карту Kakao Map с городами;
- управление кафе и загрузку фотографий владельцами;
- ненавязчивую рекламу;
- подготовку к деплою на Railway и Kakao Cloud.

---

## 1. Стек и структура проекта

**Технологии backend:**
- Node.js + Express
- MongoDB + Mongoose
- JWT (JSON Web Token) для авторизации
- bcryptjs для хеширования паролей
- multer для загрузки файлов (фото кафе)

**Фронтенд (пока без фреймворка):**
- Чистые HTML / CSS / JavaScript
- Трёхколоночный layout:
  - слева — регистрация / логин + переключатель языков;
  - центр — слайдер кафе, рекламный баннер, Kakao Map;
  - справа — список городов, список кафе, блок рекомендаций.

**Основные файлы:**
- `package.json` — конфигурация npm, зависимости, скрипты.
- `server.js` — сервер Express, подключение MongoDB, модели, API.
- `.env` — переменные окружения (порт, Mongo URI, JWT, ключи Kakao).
- `public/index.html` — главная страница.
- `public/styles.css` — стили UI.
- `public/script.js` — логика фронта (языки, города, карта).
- `uploads/` — сохраняемые на диск фото кафе.

---

## 2. Установка и запуск локально

### 2.1. Предварительные требования

- Установлен Node.js (рекомендуется 18+).
- Установлен MongoDB (локально или доступный удалённый кластер).

### 2.2. Установка зависимостей

Из корня проекта:

```bash
cd C:\Users\User\Documents\Kafe_ai
npm install
```

### 2.3. Настройка `.env`

Файл `.env` уже создан, но значения нужно адаптировать под окружение:

```env
PORT=3000
MONGODB_URI=mongodb://localhost:27017/kafe-booking
JWT_SECRET=СЛОЖНЫЙ_СЕКРЕТ_ДЛЯ_JWT
KAKAO_REST_KEY=ВАШ_KAKAO_REST_API_KEY
KAKAO_REDIRECT_URI=http://localhost:3000/api/auth/kakao/callback
```

Минимально для работы нужны:
- `PORT` — порт сервера (по умолчанию 3000).
- `MONGODB_URI` — строка подключения к MongoDB.
- `JWT_SECRET` — любой длинный случайный секрет.

### 2.4. Запуск сервера

```bash
npm start
```

Сервер запустится и будет слушать:

```text
http://localhost:3000
```

Откройте этот адрес в браузере, чтобы увидеть главную страницу.

---

## 3. Главная страница и функционал UI

Файл: `public/index.html`

### 3.1. Общий layout

- **Левая колонка**:
  - логотип `Kafe Booking`;
  - переключатель языков: 한국어 / EN / RU;
  - кнопки:
    - регистрация гостя;
    - регистрация владельца кафе;
    - логин;
  - блок «быстрое бронирование».

- **Центральная колонка**:
  - слайдер с баннерами новых/популярных кафе;
  - рекламный баннер (текст + кнопка);
  - карта Kakao Map, центрируемая по выбранному городу.

- **Правая колонка**:
  - список городов по всей Корее;
  - блок «Выбранный город»;
  - список кафе (пока примеры, позже можно подцепить реальные данные);
  - блок рекомендаций по выбранному городу.

### 3.2. Переключение языков (RU / EN / KR)

Файл: `public/script.js`

Реализован объект `translations`:

- для каждого языка (`ko`, `en`, `ru`) определены:
  - тексты UI (кнопки, заголовки, рекламные сообщения, заголовок рекомендаций);
  - словарь названий городов;
  - текстовые рекомендации по каждому городу.

При клике на кнопку языка:
- обновляются надписи на кнопках;
- заголовки и подписи блоков;
- названия городов;
- текст рекомендаций под списком кафе.

### 3.3. Список городов и рекомендации

Список городов в `index.html` и их коды:

- Основные: `seoul`, `busan`, `incheon`, `daegu`, `daejeon`, `gwangju`, `ulsan`, `jeju`
- Дополнительные: `suwon`, `seongnam`, `goyang`, `yongin`, `changwon`, `cheongju`, `jeonju`, `pohang`, `gumi`

При выборе города:
- подсвечивается активная кнопка;
- обновляется заголовок «Выбранный город» на текущем языке;
- в блоке рекомендаций показываются рекомендации по кафе и районам для этого города;
- карта Kakao Map центрируется на координаты выбранного города.

### 3.4. Kakao Map

Внизу `index.html` подключена карта Kakao:

```html
<script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=YOUR_KAKAO_JAVASCRIPT_KEY&libraries=services"></script>
<script src="script.js"></script>
```

Необходимо:
- заменить `YOUR_KAKAO_JAVASCRIPT_KEY` на JavaScript ключ из Kakao Developers;
- в настройках приложения Kakao добавить домен `http://localhost:3000`.

Логика:
- в `script.js` есть `cityCenters` — координаты центров городов;
- функция `initKakaoMap(cityCode)` центрирует карту и ставит маркер;
- при смене города карта перемещается на соответствующие координаты.

---

## 4. Модели данных в MongoDB

### 4.1. User

Файл: `server.js` — `userSchema`:

- `phone`: строка, уникальный номер телефона (для регистрации/логина по номеру).
- `kakaoId`: строка, уникальный ID из Kakao (для авторизации через Kakao).
- `name`: имя пользователя.
- `role`: роль (`user` — гость, `owner` — владелец кафе).
- `cityCode`: город пользователя (для персонализации и рекламы).
- `preferredLang`: предпочитаемый язык интерфейса (`ko`, `en`, `ru`).
- `passwordHash`: хэш пароля (используется при логине по телефону).
- `marketingOptIn`: согласие на маркетинговую рассылку.

### 4.2. Cafe

Модель `Cafe`:

- `owner`: ссылка на пользователя `User` с ролью `owner`.
- `name`: название кафе.
- `cityCode`: город, в котором находится кафе.
- `address`: адрес кафе.
- `description`: описание.
- `phone`: телефон кафе.
- `photos`: список фото (относительные URL, оригинальное имя, дата).
- `tables`: массив столов (имя, вместимость, позиция x/y — задел под схему).
- `isActive`: флаг активности (можно «выключить» кафе без удаления).

### 4.3. Ad (реклама)

Модель `Ad`:

- `title`: заголовок объявления.
- `text`: текст объявления.
- `cityCode`: город, к которому привязана реклама (или `"all"`).
- `url`: ссылка (например, на промо-страницу).
- `active`: включена ли реклама.
- `weight`: вес для сортировки (более важные кампании выше).

---

## 5. API: авторизация и пользователи

### 5.1. Регистрация по номеру телефона

`POST /api/auth/register-phone`

Тело (JSON):

```json
{
  "phone": "+82-10-1234-5678",
  "password": "strongPass123",
  "name": "Kim User",
  "role": "owner",
  "cityCode": "seoul",
  "preferredLang": "ko",
  "marketingOptIn": true
}
```

Обязательные поля: `phone`, `password`, `name`.

Ответ:
- JWT-токен (в поле `token`);
- объект `user` с базовой информацией.

### 5.2. Логин по номеру телефона

`POST /api/auth/login-phone`

Тело (JSON):

```json
{
  "phone": "+82-10-1234-5678",
  "password": "strongPass123"
}
```

Ответ:
- `token` — JWT;
- `user` — профиль пользователя.

JWT используется во всех защищённых эндпоинтах через заголовок:

```http
Authorization: Bearer <token>
```

### 5.3. План по Kakao Login

Структура уже готова:
- в модели `User` есть `kakaoId`;
- есть `KAKAO_REST_KEY` и `KAKAO_REDIRECT_URI` в `.env`;
- нужно добавить:
  - эндпоинт, принимающий `code` из Kakao;
  - запросы к `https://kauth.kakao.com/oauth/token` и `https://kapi.kakao.com/v2/user/me`;
  - создание/поиск пользователя по `kakaoId`.

---

## 6. API: кафе и владельцы (CRUD + фото)

Все действия владельцев требуют:
- `Authorization: Bearer <token>`, где `token` — JWT владельца (role=`owner`).

### 6.1. Создание кафе

`POST /api/cafes`

Тело (JSON):

```json
{
  "name": "My Cafe Hongdae",
  "cityCode": "seoul",
  "address": "서울 마포구 홍대입구...",
  "description": "Уютное кафе рядом с Hongdae.",
  "phone": "+82-10-1234-5678",
  "tables": [
    { "name": "Table 1", "capacity": 2 },
    { "name": "Table 2", "capacity": 4 }
  ]
}
```

Обязательные: `name`, `cityCode`.

Ответ:
- созданное кафе (`cafe`).

### 6.2. Редактирование информации кафе

`PUT /api/cafes/:id`

Можно передавать только те поля, которые нужно обновить:

```json
{
  "name": "My Cafe Hongdae 2.0",
  "description": "Обновлённый интерьер и меню.",
  "isActive": true
}
```

Проверка:
- кафе ищется по `_id` и `owner = текущий пользователь`, так что владелец может менять только свои кафе.

### 6.3. Получение списка кафе (для клиентов)

`GET /api/cafes?city=seoul`

Параметр `city` — код города (совпадает с кодами на фронте).

Ответ:

```json
{
  "cafes": [
    {
      "_id": "...",
      "name": "My Cafe Hongdae",
      "cityCode": "seoul",
      "address": "....",
      "description": "...",
      "phone": "...",
      "photos": [
        { "url": "/uploads/file_123.jpg", "originalName": "cafe.jpg", "createdAt": "..." }
      ]
    }
  ]
}
```

Этот эндпоинт можно привязать к правой колонке UI для отображения списка кафе вместо статичных примеров.

### 6.4. Загрузка фотографий кафе

`POST /api/cafes/:id/photos`

- Требует авторизации владельца.
- Тип запроса: `multipart/form-data`.
- Поле файла: `photo`.

Пример (Postman):
- Метод: `POST`  
- URL: `http://localhost:3000/api/cafes/<cafeId>/photos`  
- Headers: `Authorization: Bearer <token>`  
- Body: `form-data`:
  - `photo` → `File` → выбрать картинку.

Ответ:

```json
{
  "photos": [
    {
      "url": "/uploads/my_cafe_1712345678.jpg",
      "originalName": "my_cafe.jpg",
      "createdAt": "2026-01-14T..."
    }
  ]
}
```

Картинки доступны по URL:

```text
http://localhost:3000/uploads/my_cafe_1712345678.jpg
```

---

## 7. API: ненавязчивая реклама

### 7.1. Модель рекламы

Модель `Ad` (см. раздел 4.3) позволяет:
- привязывать объявления к конкретным городам;
- хранить глобальные объявления (`cityCode = "all"`).

### 7.2. Эндпоинт получения рекламы

`GET /api/ads?city=seoul`

Логика:
- выбираются только `active: true`;
- если передан `city`, фильтруются по `cityCode in [city, "all"]`;
- сортируются по `weight` (по убыванию) и по дате создания (новые выше);
- ограничиваются до 10 записей.

Фронт может:
- взять первое объявление и вывести в текущем рекламном баннере;
- или сделать небольшую ротацию (смена объявления раз в N секунд).

---

## 8. Деплой: Railway

Railway — простой способ быстро поднять проект.

### 8.1. Подготовка репозитория

- Закоммитьте всё содержимое проекта (кроме `node_modules` и локальных файлов).
- Убедитесь, что в репозитории есть:
  - `package.json` с командой `npm start`;
  - `server.js`;
  - папка `public/`.

### 8.2. Создание проекта в Railway

1. Зайдите на https://railway.app.
2. Создайте новый проект: **New Project → Deploy from GitHub Repo**.
3. Выберите репозиторий с этим кодом.
4. Railway автоматически:
   - установит зависимости (`npm install`);
   - запустит `npm start`.

### 8.3. Переменные окружения на Railway

В настройках сервиса задайте:

- `PORT` — Railway подставит свой, но код использует `process.env.PORT || 3000`, так что просто используйте тот, что даёт Railway.
- `MONGODB_URI` — строка подключения к MongoDB:
  - можно создать Mongo-сервис в Railway;
  - либо использовать MongoDB Atlas.
- `JWT_SECRET` — длинный секрет.
- `KAKAO_REST_KEY`, `KAKAO_REDIRECT_URI` — данные вашего приложения Kakao.

После деплоя Railway выдаст домен вроде:

```text
https://your-app.up.railway.app
```

Этот домен нужно:
- добавить в настройках Kakao как доверенный redirect / origin;
- использовать на фронте вместо `http://localhost:3000`.

---

## 9. Деплой: Kakao Cloud (подробный ориентир)

Для более плотной интеграции в корейскую экосистему можно развернуть проект в Kakao Cloud. Ниже — общий сценарий, который можно адаптировать под конкретные сервисы внутри Kakao Cloud (VM, Kubernetes, Load Balancer, Object Storage).

### 9.1. Подготовка Docker-образа

1. В корне проекта создайте `Dockerfile`:

   ```Dockerfile
   FROM node:18-alpine

   WORKDIR /app

   COPY package*.json ./
   RUN npm install --production

   COPY . .

   ENV NODE_ENV=production

   EXPOSE 3000

   CMD ["npm", "start"]
   ```

2. Локальная сборка и тест:

   ```bash
   docker build -t kafe-booking-app .
   docker run -p 3000:3000 --env-file .env kafe-booking-app
   ```

3. После проверки можно загрузить образ в реестр контейнеров, который поддерживает Kakao Cloud (например, private registry или внешний Docker Hub):

   ```bash
   docker tag kafe-booking-app your-registry/kafe-booking-app:latest
   docker push your-registry/kafe-booking-app:latest
   ```

### 9.2. Развёртывание backend’а в Kakao Cloud

Вариант A (через VM):

1. Создать VM в Kakao Cloud (Linux, с Docker).
2. Установить Docker (если ещё не установлен).
3. Авторизоваться в реестре контейнеров и скачать образ:

   ```bash
   docker pull your-registry/kafe-booking-app:latest
   ```

4. Запустить контейнер:

   ```bash
   docker run -d --name kafe-booking \
     -p 80:3000 \
     -e PORT=3000 \
     -e MONGODB_URI="mongodb://<mongo-host>:27017/kafe-booking" \
     -e JWT_SECRET="prod_secret" \
     -e KAKAO_REST_KEY="prod_kakao_rest_key" \
     -e KAKAO_REDIRECT_URI="https://your-domain/api/auth/kakao/callback" \
     your-registry/kafe-booking-app:latest
   ```

5. Прописать доменное имя (DNS) на IP VM или на Load Balancer, если он используется.

Вариант B (через Kubernetes / контейнерный сервис):

1. Создать кластер Kubernetes в Kakao Cloud.
2. Описать deployment и service для приложения:
   - `Deployment` с контейнером `your-registry/kafe-booking-app:latest`;
   - задать переменные окружения в манифесте или через Secret/ConfigMap.
3. Создать `Service` типа `LoadBalancer`, чтобы получить внешний IP/домен.
4. Привязать домен к выданному адресу Load Balancer.

### 9.3. База данных в Kakao Cloud

Варианты:

- MongoDB на отдельной VM:
  - установка MongoDB, настройка реплика-сета (минимум 3 инстанса для продакшена);
  - открытие порта только для backend-сервисов (Firewall/SG);
  - регулярные бэкапы (snapshot дисков или `mongodump`).

- Внешний managed MongoDB (Atlas и др.):
  - создать кластер в регионе, близком к Kakao Cloud;
  - ограничить доступ по IP адресам Kakao Cloud;
  - использовать строку подключения в `MONGODB_URI`.

Пример строки подключения:

```env
MONGODB_URI=mongodb://user:password@mongo-host:27017/kafe-booking?authSource=admin
```

### 9.4. Статика и фото (Object Storage + CDN)

На старте:
- можно оставить:
  - `public/` и `uploads/` на том же сервере;
  - Express уже раздаёт статику и файлы.

Для продакшена рекомендуется:

1. Подключить Object Storage в Kakao Cloud (аналог S3).
2. При загрузке фото кафе:
   - вместо записи в `uploads/` загружать файл в Object Storage;
   - в БД сохранять только публичный URL.
3. Настроить CDN поверх Object Storage:
   - уменьшает задержку;
   - разгружает backend.

### 9.5. Конфигурация и секреты

Все важные параметры уже вынесены в `process.env`:

- `PORT`
- `MONGODB_URI`
- `JWT_SECRET`
- `KAKAO_REST_KEY`
- `KAKAO_REDIRECT_URI`

В Kakao Cloud их нужно задавать:
- либо через переменные окружения контейнера;
- либо через Secret/ConfigMap (в Kubernetes);
- либо через системные настройки VM.

---

## 10. Следующие шаги развития проекта (подробно)

### 10.1. Интеграция фронта с backend API

Задача: сделать так, чтобы текущий frontend реально работал с API (регистрация, логин, кафе, реклама).

1. **Регистрация и логин на фронте**:
   - В `index.html` формы регистрации и логина уже существуют.
   - В `public/script.js`:
     - добавить обработчики `submit` для форм;
     - для регистрации:
       - отправлять `fetch('/api/auth/register-phone', { method: 'POST', body: JSON.stringify(...), headers: { 'Content-Type': 'application/json' } })`;
       - по успешному ответу сохранять `token` в `localStorage` или `sessionStorage`.
     - для логина:
       - аналогично вызывать `/api/auth/login-phone`;
       - сохранять `token`.

2. **Подстановка токена в запросы**:
   - создать функцию-обёртку над `fetch`, которая:
     - берёт `token` из `localStorage`;
     - добавляет заголовок `Authorization: Bearer <token>` при наличии.

3. **Загрузка списка кафе**:
   - при выборе города:
     - помимо обновления UI и карты вызвать `GET /api/cafes?city=<cityCode>`;
     - отрисовать список кафе справа (название, короткое описание, рейтинг, фото).

4. **Рекламный баннер**:
   - при загрузке страницы:
     - вызвать `GET /api/ads?city=<currentCityCode>`;
     - выбрать первое объявление или рандомное;
     - подставить текст и ссылку в блок рекламы.

### 10.2. Кабинет владельца кафе (web UI)

Цель: дать владельцу кафе удобный интерфейс вместо Postman.

Варианты:
- сделать отдельную страницу `/owner.html`;
- или модальное окно/панель на существующей странице.

Функционал:

1. **Авторизация владельца**:
   - использовать уже существующий логин;
   - при успехе проверять `user.role === 'owner'`;
   - показывать «Кабинет владельца».

2. **Форма создания кафе**:
   - поля: название, город, адрес, описание, телефон.
   - отправка на `POST /api/cafes` с токеном.

3. **Редактирование кафе**:
   - получать список своих кафе (`GET /api/cafes?city=<...>` и фильтровать по owner на backend или сделать отдельный эндпоинт `/api/my-cafes`).
   - при выборе кафе:
     - показывать форму редактирования (название, описание, телефон, статус `isActive`).
     - отправлять `PUT /api/cafes/:id`.

4. **Загрузка фото**:
   - для выбранного кафе:
     - добавить форму с type `multipart/form-data` и полем `photo`;
     - отправлять `POST /api/cafes/:id/photos` с токеном.
   - отображать список уже загруженных фото (миниатюры с URL из `photos`).

### 10.3. Реализация Kakao Login

Основные шаги:

1. **Настройка приложения в Kakao Developers**:
   - зарегистрировать приложение;
   - указать:
     - Redirect URI: `https://your-domain/api/auth/kakao/callback` (и `http://localhost:3000/...` для разработки);
   - получить `REST API Key` и `JavaScript Key`.

2. **Backend: OAuth flow**:
   - добавить эндпоинт:
     - `GET /api/auth/kakao/login`:
       - редиректит на `https://kauth.kakao.com/oauth/authorize?...` с параметрами `client_id`, `redirect_uri`, `response_type=code`.
   - добавить callback:
     - `GET /api/auth/kakao/callback?code=...`:
       - по `code` запрашивает access token у `https://kauth.kakao.com/oauth/token`;
       - по access token запрашивает профиль пользователя у `https://kapi.kakao.com/v2/user/me`;
       - берет `id` (Kakao Account ID) и, при необходимости, имя/почту;
       - ищет пользователя с `kakaoId = id`:
         - если найден — логинит;
         - если нет — создаёт нового пользователя (`User` с `kakaoId`, без пароля);
       - выдаёт JWT по тому же принципу, что и при логине по телефону.

3. **Frontend**:
   - добавить кнопку «Войти через Kakao»;
   - при клике:
     - перенаправлять на `/api/auth/kakao/login`;
   - после успешного callback’a:
     - backend может редиректнуть на фронтовый URL с JWT в query или cookie;
     - фронт его сохранит и будет использовать для приватных запросов.

### 10.4. Система бронирований (Booking)

Архитектура:

1. **Модель Booking**:
   - поля:
     - `user`: ссылка на `User` (кто бронирует);
     - `cafe`: ссылка на `Cafe`;
     - `tableId` или `tableName`;
     - `startTime`, `endTime` (время брони);
     - `status`: `pending`, `confirmed`, `cancelled`, `completed`;
     - `createdAt`.

2. **Эндпоинты**:
   - `POST /api/bookings`:
     - пользователь выбирает кафе, стол, время;
     - создаётся бронь в статусе `pending` или `confirmed`.
   - `GET /api/bookings/my`:
     - список броней текущего пользователя.
   - `GET /api/cafes/:id/bookings`:
     - для владельца кафе — список броней его кафе.
   - `PUT /api/bookings/:id`:
     - изменение статуса (например, владелец подтверждает или отменяет бронь).

3. **Проверка доступности столов**:
   - при создании брони:
     - проверять, что на указанный интервал нет других активных броней для того же стола.

4. **UI**:
   - для гостей:
     - при клике на кафе → показывать список столов, календарь/время;
     - отправка брони;
   - для владельцев:
     - в кабинете показывать список броней;
     - кнопки подтверждения/отмены.

### 10.5. Мобильные приложения (Android / iOS)

#### 10.5.1. Выбор технологии

Рекомендуется использовать кроссплатформенный подход:

- **React Native** или **Flutter**:
  - один код — две платформы (Android и iOS);
  - проще повторно использовать UI-логика и API-вызовы.

Бэкенд уже даёт REST API, которое удобно использовать с любого клиента.

#### 10.5.2. Архитектура мобильного клиента

Основные экраны:

- Экран приветствия / онбординг.
- Экран логина/регистрации:
  - по телефону (через API `/api/auth/*`);
  - через Kakao (через WebView/SDK).
- Главное окно:
  - выбор города (список, как на вебе);
  - список кафе для города (`GET /api/cafes?city=...`);
  - просмотр деталей кафе (описание, фото, расположение на карте).
- Экран бронирования:
  - выбор даты/времени, стола;
  - отправка на `/api/bookings`.
- Экран «Мои бронирования»:
  - список броней, статусы.

Интеграция с backend:

- Создать модуль API:
  - базовый URL (`https://your-domain/api`);
  - методы для:
    - регистрации/логина;
    - получения городов/кафе/рекламы;
    - создания/просмотра броней.
- Хранить JWT в безопасном хранилище:
  - Android: EncryptedSharedPreferences/Keystore;
  - iOS: Keychain;
  - или абстракции, которые дают библиотеки под React Native/Flutter.

#### 10.5.3. Публикация в Google Play (Android)

1. Создать **Google Play Console** аккаунт.
2. Подготовить Android билд:
   - задать package name (например, `com.kafebooking.app`);
   - настроить подпись приложения (release keystore);
   - собрать release APK/AAB.
3. Подготовить материалы:
   - иконка приложения;
   - скриншоты (телефоны, планшеты);
   - краткое и полное описание (на корейском, русском, английском, по желанию);
   - возрастной рейтинг;
   - политика конфиденциальности (URL).
4. В Play Console:
   - создать новое приложение;
   - заполнить все требуемые разделы (Store listing, Content rating, App content);
   - загрузить AAB/APK;
   - пройти проверку и отправить на публикацию.

#### 10.5.4. Публикация в Apple App Store (iOS)

1. Оформить аккаунт разработчика Apple (Apple Developer Program).
2. Настроить проект:
   - уникальный Bundle ID (например, `com.kafebooking.app`);
   - профили подписания, сертификаты;
   - целевые версии iOS.
3. Собрать iOS-приложение:
   - с помощью Xcode (или через CI);
   - загрузить билд в App Store Connect (через Xcode или Transporter).
4. В App Store Connect:
   - создать приложение;
   - заполнить метаданные:
     - название, описание, ключевые слова;
     - скриншоты (разные устройства/разрешения);
     - иконка;
     - политика конфиденциальности.
5. Указать:
   - использование API Kakao/геолокации;
   - обработку личных данных (согласно App Privacy Details).
6. Отправить на ревью:
   - дождаться проверки Apple;
   - при необходимости — ответить на вопросы ревьюеров.

#### 10.5.5. Синхронизация web и mobile

- Общий backend (одни и те же API и база).
- Общий аккаунт пользователя:
  - логин и брони на вебе должны быть видны на мобилке и наоборот.
- Важно:
  - аккуратно версионировать API;
  - при обновлении backend не ломать совместимость с уже выпущенными мобильными версиями.

### 10.6. Платные тарифы, реклама и вывод средств на корейский банковский счёт

#### 10.6.1. Модели и тарифы в backend

В `server.js` добавлены поля и модель для работы с тарифами:

- `User`:
  - `isAdmin`: флаг администратора;
  - `isInvestor`: флаг инвестора;
  - `subscriptionPlan`: один из:
    - `none` — без платного тарифа;
    - `client` — обычный клиентский премиум (2000₩, меньше рекламы/доп.функции);
    - `coffee` — «Coffee Premium» для владельцев кафе (25000₩, без рекламы);
    - `invest` — «Invest Premium» для инвесторов (отдельный сервис);
  - `subscriptionExpiresAt`: дата окончания подписки.
- `Payment`:
  - `user`: ссылка на пользователя;
  - `plan`: `client` | `coffee` | `invest`;
  - `amountWon`: сумма в вонаx;
  - `currency`: обычно `KRW`;
  - `status`: `pending` | `paid` | `failed` | `refunded`;
  - поля для интеграции с платёжным провайдером (`provider`, `providerPaymentId`, `paidAt`, `metadata`).

Эндпоинты:

- `POST /api/payments/subscribe`:
  - принимает `plan` (`client`, `coffee`, `invest`);
  - создаёт запись `Payment` со статусом `pending`;
  - выставляет суммы:
    - `client` → `2000`;
    - `coffee` → `25000`;
    - `invest` → `0` (можно использовать как заявку инвестора).
- `GET /api/ads`:
  - если запрос приходит с JWT и у пользователя `subscriptionPlan = client` или `coffee`, возвращает пустой список рекламы (эффект «без рекламы»).

#### 10.6.2. Роли и админка

Для управления проектом добавлена админ‑логика:

- поле `isAdmin` в `User`;
- middleware `adminOnly`;
- эндпоинты:
  - `GET /api/admin/users` — список пользователей с тарифами;
  - `PATCH /api/admin/users/:id/subscription` — ручное управление:
    - `subscriptionPlan`;
    - `subscriptionExpiresAt`;
    - флагами `isAdmin`, `isInvestor`;
  - `GET /api/admin/cafes` / `PATCH /api/admin/cafes/:id` — управление активностью кафе;
  - `GET /api/admin/ads`, `POST /api/admin/ads`, `PATCH /api/admin/ads/:id` — управление рекламой.

Вход в админку:

- первый админ настраивается через базу (ручное изменение `isAdmin = true`);
- дальше админ может назначать других админов через API.

#### 10.6.3. Как клиент открывает своё кафе

Поток:

1. Пользователь регистрируется как обычный клиент (`role = user`).
2. Если он решает открыть своё кафе:
   - на фронте появляется кнопка «Стать владельцем кафе»;
   - она вызывает `POST /api/profile/become-owner` с JWT.
3. Backend:
   - меняет `role` на `owner`;
   - возвращает обновлённый JWT.
4. После этого пользователь может создавать кафе через `POST /api/cafes`.

Такой подход позволяет:

- не плодить разные аккаунты;
- мягко переводить клиента в владельца кафе.

#### 10.6.4. Ненавязчивая реклама

Реклама хранится в модели `Ad` и отдаётся через:

- публичный `GET /api/ads`:
  - максимум несколько записей (`limit` уменьшен до 5);
  - сортировка по `weight` и времени создания.

Ненавязчивость достигается за счёт:

- ограничения количества баннеров;
- привязки к городу (`cityCode`) для повышения релевантности;
- отключения рекламы для платных тарифов (`client`, `coffee`).

На фронтенде:

- можно показывать рекламный блок только в одном месте (например, справа или под списком кафе);
- не использовать всплывающие окна/оверлеи, а только виджеты в макете.

#### 10.6.5. Вывод средств на корейский банковский счёт (архитектура)

Важно: фактическая интеграция с банком/PG зависит от выбранного провайдера. Здесь описан общий путь для Кореи.

1. Юридическая подготовка:
   - зарегистрировать бизнес (индивидуальный предприниматель или юр.лицо) по корейским правилам;
   - открыть бизнес‑счёт в корейском банке (KB, Shinhan, K‑Bank и др.).
2. Выбор платёжного провайдера (PG):
   - примеры: Toss Payments, KakaoPay, NICE Payments и др.;
   - заключить договор, получить ключи API, тестовый/боевой мерчант‑ID.
3. Архитектура платежей:
   - фронтенд вызывает ваш backend (`POST /api/payments/subscribe`) с выбранным тарифом;
   - backend создаёт `Payment` со статусом `pending` и вызывает API PG:
     - либо создаёт платёжную сессию и отдаёт фронтенду URL/крипту для редиректа;
     - либо возвращает параметры для SDK (в мобильном приложении).
   - после успешной оплаты PG вызывает ваш callback (например, `POST /api/payments/confirm`):
     - вы проверяете подпись/подлинность уведомления;
     - обновляете `Payment.status = paid`, `paidAt = now`, сохраняете `providerPaymentId`;
     - выставляете пользователю `subscriptionPlan` и `subscriptionExpiresAt`.
4. Settlement (зачисление на банковский счёт):
   - PG агрегирует оплаты клиентов;
   - раз в определённый период (день/неделя/месяц) автоматически перечисляет сумму за вычетом комиссии на ваш корейский счёт;
   - отчёты PG можно использовать для сверки с коллекцией `Payment`.
5. Учёт тарифов:
   - для `client` (2000₩) и `coffee` (25000₩):
     - при `paid` статусе:
       - включить соответствующий тариф;
       - поставить дату окончания (например, +30 дней).
   - для `invest`:
     - можно использовать как заявку:
       - `Payment.plan = invest`, `status = pending`;
       - админ связывается с инвестором, заключает отдельное соглашение;
       - после подтверждения ставит `isInvestor = true`, опционально отдельный биллинг.

#### 10.6.6. Безопасность платежей и проекта

Усиления, реализованные в backend:

- добавлен `helmet()` для базовой защиты HTTP‑заголовков;
- добавлен `rateLimit` на `/api/auth/*`:
  - защита от перебора логинов/паролей (ограничение числа запросов в окно времени);
- JWT содержит только минимально необходимую информацию (id, role, isAdmin, subscriptionPlan);
- пароли пользователей хранятся только в виде хеша (`bcrypt`).

Рекомендованные дополнительные меры:

- ограничить CORS в продакшене на конкретные домены (`coffeeb.co.kr`, мобильные клиенты);
- добавить валидацию входящих данных (например, через `joi`/`zod` или аналоги);
- логировать подозрительные активности (частые логины, ошибки авторизации, странные запросы);
- регулярно обновлять зависимости и мониторить уязвимости (`npm audit`).

#### 10.6.7. Старт интеграции с Toss Payments / KakaoPay

Для полной автоматизации подписок и вывода средств подключается корейский PG (Toss Payments, KakaoPay и т.п.).

1. Переменные окружения:
   - добавить в `.env`:
     - `TOSS_SECRET_KEY`, `TOSS_CLIENT_KEY`, `TOSS_SUCCESS_URL`, `TOSS_FAIL_URL`;
     - `KAKAOPAY_ADMIN_KEY`, `KAKAOPAY_CID`, `KAKAOPAY_REDIRECT_URL`.
2. Использование `/api/payments/subscribe`:
   - фронтенд уже создаёт `Payment` со статусом `pending` при выборе тарифа;
   - следующий шаг:
     - после создания `Payment` backend:
       - вызывает API Toss/KakaoPay для создания платёжной сессии;
       - получает `checkoutUrl` (или аналогичный URL);
       - возвращает его на фронтенд.
   - фронт:
     - при наличии `checkoutUrl` делает редирект на страницу оплаты.
3. Callback после оплаты:
   - на стороне PG настраиваются SUCCESS/FAIL/Redirect URL;
   - backend добавляет обработчики:
     - например, `/api/payments/toss/callback`, `/api/payments/kakaopay/callback`;
   - внутри:
     - проверяется подпись/подлинность вызова;
     - по данным PG находится запись `Payment`;
     - статус переводится в `paid`/`failed`, сохраняется ID транзакции;
     - при `paid`:
       - обновляется `subscriptionPlan` и `subscriptionExpiresAt` у пользователя.
4. Связка с фронтендом:
   - после успешной оплаты пользователь возвращается на сайт (`SUCCESS_URL`);
   - фронт:
     - показывает страницу «оплата успешна»;
     - вызывает `/api/profile/me`, чтобы отобразить новый тариф.
5. Масштабирование:
   - поле `Payment.provider` позволяет поддерживать несколько PG;
   - логика подписок (`subscriptionPlan`) при этом остаётся единой.
